{"version":3,"sources":["logo.svg","Components/GridSquare.js","Components/Dashboard.js","Algorithms/Dijkstra.js","Algorithms/Astar.js","Maze Algorithms/RecursiveDivision.js","Maze Algorithms/RandomMaze.js","App.js","reportWebVitals.js","index.js"],"names":["GridSquare","row","col","maingrid","updatethegrid","updateGrid","StartBtnclicked","EndBtnclicked","startendpos","updateStartEnd","value","useState","setItem","onchange","newValue","prevState","newItem","newArray","bGColor","backgroundColor","borderWidth","className","onClick","onMouseOver","e","buttons","style","Dashboard","props","changeAlgorithm","newAlgorithm","updateAlgorithm","changeSpeed","newSpeed","updateSpeed","changeMaze","newMaze","a","updateMaze","displayMaze","GenerateMaze","Dropdown","as","ButtonGroup","Toggle","variant","fontSize","speed","Menu","Item","target","textContent","eventKey","display","finaldistance","nodesVisited","algorithm","updateStartBtn","updateEndBtn","marginBottom","clearGrid","VisualizeAlgorithm","maze","isWall","updateFinalDistance","updateNodesVisited","rownumbers","colnumbers","sleepms","startRow","startCol","endRow","endCol","currentPosX","currentPosY","visitedNodes","push","distance","previousNode","vertexSetQ","targetreached","Infinity","numberofVisitedNodes","sort","b","u","shift","weight","includes","alt","unshift","sleep","prev","shortestPath","btrow","btcol","temp","pathdistance","i","length","time","Promise","resolve","setTimeout","h","getHeuristic","f","currentX","currentY","targetX","targetY","Math","pow","outborder","width","height","CreateExtBorder","addInnerWalls","horizontal","minX","maxX","minY","maxY","y","floor","randomNumber","hole","addHWall","x","addVWall","grid","lowNum","highNum","random","rand","App","startgrid","useMemo","updateStartEndPos","newrow","newcol","updatewhat","newStartEnd","Grid","newArr","Dijkstra","Astar","recursivedivision","randomMaze","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.cfe02df7.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/logo.6ce24c58.svg\";","import React from \"react\";\r\nimport { useState} from 'react';\r\nimport { css } from \"styled-components\";\r\nimport styled, {keyframes } from \"styled-components\";\r\n\r\nconst GridSquare = ({row, col, maingrid, updatethegrid, updateGrid, StartBtnclicked, EndBtnclicked, startendpos, updateStartEnd }) => {\r\n    \r\n    //Weight of Current Node\r\n    var weight = maingrid[row][col][1]\r\n\r\n    \r\n    //Values : 0:Empty; 1:Wall; 2:Start; 3:Target;  4:SearchPath; 5:FinalPath;\r\n    if(row == startendpos[0] && col == startendpos[1]){ //Check if current cell is the startnode\r\n        updatethegrid(row, col, 2)\r\n        var value = 2\r\n    } \r\n    else if(row == startendpos[2] && col == startendpos[3]) {\r\n        updatethegrid(row, col, 3)\r\n        var value = 3\r\n    }\r\n    else{\r\n        var value = maingrid[row][col][0]\r\n    }\r\n    \r\n    \r\n    //nodevalue = '1' ? maingrid[row][col] = '1' : maingrid[row][col] = '0';\r\n\r\n\r\n    //MOST AWESOME METHOD EVER\r\n    //Change Parent State array element without rerendering whole array again\r\n    // so no more slow anymore !\r\n    const [item, setItem] = useState(value);\r\n    \r\n    function onchange() {\r\n        let newValue = 0;\r\n        if(value === 1){\r\n            newValue = 0\r\n        }\r\n        if(value === 0){\r\n            newValue = 1\r\n        }\r\n        if(StartBtnclicked === true){ // If start button was toggled on !\r\n            updateStartEnd(row, col, 2)\r\n            newValue = 2\r\n        }\r\n        \r\n        if(EndBtnclicked === true){ // If start button was toggled on !\r\n            updateStartEnd(row, col, 3)\r\n            newValue = 3\r\n        }\r\n\r\n\r\n\r\n        setItem(prevState => {\r\n            \r\n          let newItem = newValue;\r\n            \r\n          // sync with [arent array]\r\n          updatethegrid(row, col, newItem, 0);\r\n          return newItem;\r\n        });\r\n\r\n        // If wall, remove it forcefully so we'll use updateGrid instead of updatethegrid which is faster\r\n        if(value === 1){\r\n            var newArray = [...maingrid]; //clone maingrid \r\n            newArray[row][col][0] = 0;\r\n            updateGrid([...newArray]);\r\n        }\r\n    }\r\n\r\n    \r\n\r\n    const startblock = <div className='btn btn-primary'></div>;\r\n\r\n    \r\n   let bGColor = {\r\n        //backgroundColor: \"white\",\r\n      };\r\n\r\n    if(value == 2){ // Start CSS\r\n        bGColor = { backgroundColor: \"#19ff38\", borderWidth : \"20px\" }; \r\n    }\r\n\r\n    if(value == 3){ // Target End CSS\r\n        bGColor = { backgroundColor: \"#f74848\", borderWidth : \"20px\"}; \r\n    }\r\n\r\n    var mover = false;\r\n\r\n    function mouseDown() {\r\n        if(mover == true){\r\n            //onchange();\r\n            console.log(\"clicked\")\r\n        }\r\n    }\r\n\r\n    function mouseStatus(check) {\r\n        if(check == true){\r\n            mover = true;\r\n        }\r\n    }\r\n\r\n\r\n    return (\r\n        <div className={\"gridsquare \" + (value === 1 ? \"wallAnimation \" : '') + (value === 4 ? \"loadingAnimation \" : '') + (value === 5 ? \"pathfoundAnimation \" : '')} onClick={onchange} onMouseOver={function(e){\r\n            if(e.buttons == 1 || e.buttons == 3){\r\n                if(value !== 1){\r\n                    onchange();\r\n                }\r\n            }\r\n        }} style={bGColor}>\r\n           \r\n        </div>\r\n    )\r\n\r\n    // INTERESTING CSS Styling with If and Else\r\n    //<div className='gridsquare'   onClick={onchange} style={{ backgroundColor : value === 1 ? '#007BFF' : value === 2 ?  '#19ff38' : value === 3 ?  '#f74848' : value === 4 ?  '#f4ff59' : value === 5 ?  '#33daff' : '' }}>\r\n      \r\n}\r\n\r\nexport default GridSquare\r\n","import { FaBomb } from 'react-icons/fa';\r\nimport { HiOutlineRefresh } from 'react-icons/hi';\r\nimport { VscRunAll, VscDebugStart } from 'react-icons/vsc';\r\nimport { FaWeightHanging } from 'react-icons/fa';\r\nimport { FaDoorOpen } from 'react-icons/fa';\r\nimport { GiPlayButton, GiMaze} from 'react-icons/gi';\r\nimport { BiNetworkChart, BiTargetLock } from 'react-icons/bi';\r\nimport { BsLightningFill} from 'react-icons/bs';\r\nimport { AiOutlineBlock} from 'react-icons/ai';\r\n\r\nimport { Dropdown} from 'react-bootstrap';\r\nimport ButtonGroup from \"react-bootstrap/ButtonGroup\";\r\n\r\nconst Dashboard = (props) => {\r\n\r\n   function changeAlgorithm(newAlgorithm) {\r\n      props.updateAlgorithm(newAlgorithm)\r\n   }\r\n\r\n   function changeSpeed(newSpeed) {\r\n      props.updateSpeed(newSpeed)\r\n   }\r\n\r\n   async function changeMaze(newMaze) {\r\n      await props.updateMaze(newMaze)\r\n      //alert(props.maze)\r\n      displayMaze();\r\n   }\r\n\r\n   function displayMaze(){\r\n      props.GenerateMaze();\r\n   }\r\n\r\n    return (\r\n      <div>\r\n         <div className='topleftdashboard'>\r\n            <Dropdown as={ButtonGroup}>\r\n               <Dropdown.Toggle variant=\"light\" className=\"speedDropDown\"><BsLightningFill style={{fontSize: '20px'}}/> {props.speed}</Dropdown.Toggle>\r\n               <Dropdown.Menu>\r\n                  <Dropdown.Item onClick={(e) => changeSpeed(e.target.textContent)} eventKey=\"1\">Instant</Dropdown.Item>\r\n                  <Dropdown.Item onClick={(e) => changeSpeed(e.target.textContent)} eventKey=\"2\">Fast</Dropdown.Item>\r\n                  <Dropdown.Item onClick={(e) => changeSpeed(e.target.textContent)} eventKey=\"3\">Medium</Dropdown.Item>\r\n                  <Dropdown.Item onClick={(e) => changeSpeed(e.target.textContent)} eventKey=\"4\">Slow</Dropdown.Item>\r\n               </Dropdown.Menu>\r\n            </Dropdown>\r\n            <div className=\"statText mt-2 font-italic\">Distance: <div style={{display: \"inline-block\"}}>{props.finaldistance}</div></div>\r\n            <div className=\"statText mt-1 font-italic\">Visited: <div style={{display: \"inline-block\"}}>{props.nodesVisited}</div></div>\r\n\r\n         </div>\r\n\r\n          <div className='bottomdashboard row'>\r\n            <div className=\"col-3 d-flex justify-content-center\">\r\n               <Dropdown as={ButtonGroup} >\r\n                  <Dropdown.Toggle variant=\"primary\" className=\"algoDropDown\"><BiNetworkChart style={{fontSize: '25px'}}/> {props.algorithm}</Dropdown.Toggle>\r\n                  <Dropdown.Menu>\r\n                     <Dropdown.Item onClick={(e) => changeAlgorithm(e.target.textContent)} eventKey=\"1\">Dijkstra's Algorithm</Dropdown.Item>\r\n                     <Dropdown.Item onClick={(e) => changeAlgorithm(e.target.textContent)} eventKey=\"2\">A* Algorithm</Dropdown.Item>\r\n                  </Dropdown.Menu>\r\n               </Dropdown>\r\n            </div>\r\n               \r\n            <div className=\"col-6 d-flex justify-content-center\">\r\n               <button className='dashboardbtn btn btn-warning' onClick={() => props.updateStartBtn(value => !value)}> \r\n                  <GiPlayButton style={{fontSize: '25px'}}/> Start\r\n               </button>\r\n               <button className='dashboardbtn btn btn-danger' onClick={() => props.updateEndBtn(value => !value)}> \r\n                  <BiTargetLock style={{fontSize: '25px'}}/> Target\r\n               </button>\r\n               <button className='dashboardbtn btn btn-dark'> \r\n                  <FaWeightHanging style={{fontSize: '15px', marginBottom: '5px'}}/> Weight\r\n               </button>\r\n               <button className='dashboardbtn btn btn-info' onClick = {() => props.clearGrid()}> \r\n                  <HiOutlineRefresh style={{fontSize: '25px'}}/> Clear\r\n               </button>\r\n               <button className='dashboardbtn btn btn-success' onClick={() => props.VisualizeAlgorithm()}> \r\n                  <VscRunAll style={{fontSize: '25px'}}/> Simulate\r\n               </button>\r\n            </div>\r\n\r\n            <div className=\"col-3 d-flex justify-content-center\">\r\n               <Dropdown as={ButtonGroup}>\r\n                  <Dropdown.Toggle variant=\"primary\" className=\"algoDropDown\"><AiOutlineBlock style={{fontSize: '25px'}}/> {props.maze}</Dropdown.Toggle>\r\n                  <Dropdown.Menu>\r\n                     <Dropdown.Item onClick={(e) => changeMaze(e.target.textContent)} eventKey=\"1\">Recursive Division</Dropdown.Item>\r\n                     <Dropdown.Item onClick={(e) => changeMaze(e.target.textContent)} eventKey=\"2\">Random Maze</Dropdown.Item>\r\n                  </Dropdown.Menu>\r\n               </Dropdown>\r\n            </div>\r\n\r\n         </div>\r\n      </div>\r\n     \r\n    )\r\n}\r\n\r\nexport default Dashboard\r\n","\r\n  // Understanding Dijkstra : \r\n  // https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#Pseudocode\r\n  // https://levelup.gitconnected.com/dijkstras-shortest-path-algorithm-in-a-grid-eb505eb3a290\r\n  // https://stackoverflow.com/questions/56609206/how-do-i-keep-track-of-the-shortest-paths-in-the-dijkstra-algorithm-when-using-a\r\n  // Dijkstra Algorithm - Super optimized\r\n\r\nexport async function Dijkstra(maingrid, updateGrid, isWall, updateFinalDistance, updateNodesVisited, startendpos, rownumbers, colnumbers, speed) {\r\n    \r\n    // for Speed of animation\r\n    var sleepms = 4; // 4 is minimum\r\n    if(speed == \"Instant\"){sleepms = 0;}\r\n    if(speed == \"Speed\"){sleepms = 4;}\r\n    if(speed == \"Fast\"){sleepms = 4;}\r\n    if(speed == \"Medium\"){sleepms = 200;}\r\n    if(speed == \"Slow\"){sleepms = 1000;}\r\n      \r\n\r\n    const startRow = startendpos[0]; // row number of start\r\n    const startCol = startendpos[1]; // col number of start\r\n    const endRow = startendpos[2];\r\n    const endCol = startendpos[3];\r\n\r\n    var newArray = [...maingrid]; //clone maingrid \r\n    \r\n    // Getting starting positions \r\n    var currentPosX = startRow;\r\n    var currentPosY = startCol;\r\n    \r\n    // Gathers all visited Nodes so that we wont visit again\r\n    var visitedNodes = [];\r\n    // add start node as visited\r\n    visitedNodes.push(startRow + \":\" + startCol) // add startNode cuz no need to visit again\r\n\r\n    var distance = []; // Distance of each nodes to start\r\n    var previousNode = []; // Previous Nodes\r\n\r\n    // Important\r\n    // VertexSetQ contains distance of Node f/ start , Row number, Column number\r\n    var vertexSetQ = []; \r\n\r\n    var targetreached = false; // check if target is reacher\r\n\r\n    for (var row = 0; row < rownumbers; row++) {\r\n      distance[row] = [];\r\n      previousNode[row] = [];\r\n      //vertexSetQ[row] = [];\r\n      for (var col = 0; col < colnumbers; col++) {\r\n        distance[row][col] = Infinity; // first is Type, second: X of previous node; third : Y of previous node\r\n        previousNode[row][col] = [-1,-1]; // first is Type, second: X of previous node; third : Y of previous node\r\n        if(row == startRow && col == startCol){distance[row][col] = 0;}\r\n      }\r\n    }\r\n    vertexSetQ.push([0, startRow, startCol]);\r\n\r\n    var numberofVisitedNodes = 0;\r\n    \r\n    while(targetreached == false){\r\n      \r\n      vertexSetQ = vertexSetQ.sort(function(a,b) {return a[0]-b[0]});\r\n      var u = vertexSetQ[0];\r\n      vertexSetQ.shift(); // remove the smallest node from stack\r\n      \r\n      var currentPosX = u[1];\r\n      var currentPosY = u[2];\r\n      //alert(currentPosX);\r\n      var weight = 1; // Change weight if necessary\r\n\r\n      // if target is reached, stop everything\r\n      if(currentPosX === endRow && currentPosY === endCol){\r\n        targetreached = true;\r\n        break;\r\n      }\r\n      \r\n      // add this current node to visited\r\n      visitedNodes.push(currentPosX + \":\" + currentPosY)\r\n      \r\n      if(visitedNodes.includes((currentPosX-1) + \":\" + currentPosY)  === false && currentPosX-1 >= 0 && isWall(currentPosX-1, currentPosY) == false ){\r\n        var alt = distance[currentPosX][currentPosY] + weight;\r\n        if(alt < distance[currentPosX-1][currentPosY]){\r\n          distance[currentPosX-1][currentPosY] = alt;\r\n          previousNode[currentPosX-1][currentPosY] = [currentPosX, currentPosY];\r\n          vertexSetQ.unshift([distance[currentPosX-1][currentPosY],currentPosX-1,currentPosY])\r\n          newArray[currentPosX-1][currentPosY][0] = 4;\r\n          numberofVisitedNodes++;\r\n        }\r\n      }\r\n\r\n      if(visitedNodes.includes(currentPosX + \":\" + (currentPosY-1) ) === false && currentPosY-1 >= 0 && isWall(currentPosX, currentPosY-1) == false ){\r\n        var alt = distance[currentPosX][currentPosY] + weight;\r\n        if(alt < distance[currentPosX][currentPosY-1]){\r\n          distance[currentPosX][currentPosY-1] = alt;\r\n          previousNode[currentPosX][currentPosY-1] = [currentPosX, currentPosY];\r\n          vertexSetQ.unshift([distance[currentPosX][currentPosY-1],currentPosX,currentPosY-1])\r\n          newArray[currentPosX][currentPosY-1][0] = 4;\r\n          numberofVisitedNodes++;\r\n        }\r\n      }\r\n      if(visitedNodes.includes((currentPosX+1) + \":\" + currentPosY)  === false && currentPosX+1 < rownumbers && isWall(currentPosX+1, currentPosY) == false ){\r\n        var alt = distance[currentPosX][currentPosY] + weight;\r\n        if(alt < distance[currentPosX+1][currentPosY]){\r\n          distance[currentPosX+1][currentPosY] = alt;\r\n          previousNode[currentPosX+1][currentPosY] = [currentPosX, currentPosY];\r\n          vertexSetQ.unshift([distance[currentPosX+1][currentPosY],currentPosX+1,currentPosY])\r\n          newArray[currentPosX+1][currentPosY][0] = 4;\r\n          numberofVisitedNodes++\r\n        }\r\n      }\r\n      if(visitedNodes.includes(currentPosX + \":\" + (currentPosY+1))  === false && currentPosY+1 < colnumbers && isWall(currentPosX, currentPosY+1) == false){\r\n        var alt = distance[currentPosX][currentPosY] + weight;\r\n        if(alt < distance[currentPosX][currentPosY+1]){\r\n          distance[currentPosX][currentPosY+1] = alt;\r\n          previousNode[currentPosX][currentPosY+1] = [currentPosX, currentPosY];\r\n          vertexSetQ.unshift([distance[currentPosX][currentPosY+1],currentPosX,currentPosY+1])\r\n          newArray[currentPosX][currentPosY+1][0] = 4;\r\n          numberofVisitedNodes++;\r\n        }\r\n      }\r\n      \r\n      if(sleepms !== 0){\r\n        await sleep((sleepms));\r\n      }\r\n      updateGrid([...newArray]);\r\n    }\r\n    \r\n    updateNodesVisited(prev => prev + numberofVisitedNodes + 1);\r\n    \r\n    // Backtracking from End Node to Start Node\r\n    var shortestPath = [];\r\n    var btrow = endRow; // backtracking to start\r\n    var btcol = endCol;\r\n\r\n    if (typeof previousNode[endRow][endCol] !== 'undefined'){\r\n      while(true){\r\n        if(btrow == startRow && btcol == startCol){\r\n          break;\r\n        }\r\n        shortestPath.unshift([btrow,btcol]);\r\n        var temp = previousNode[btrow][btcol];\r\n        btrow = temp[0];\r\n        btcol = temp[1];\r\n      }\r\n    }\r\n    \r\n    var pathdistance = 0;\r\n    for(var i = 0; i< shortestPath.length; i++){\r\n      newArray[shortestPath[i][0]][shortestPath[i][1]][0] = 5;\r\n      \r\n      if(sleepms !== 0){\r\n        await sleep((sleepms));\r\n      }\r\n      pathdistance++;\r\n      updateFinalDistance(pathdistance)\r\n      updateGrid([...newArray]);\r\n    }\r\n  }\r\n  \r\n\r\n  function sleep(time) {\r\n    return new Promise(resolve => setTimeout(()=>resolve(), time));\r\n  }\r\n","// https://en.wikipedia.org/wiki/A*_search_algorithm\r\n\r\nexport async function Astar(maingrid, updateGrid, isWall, updateFinalDistance, updateNodesVisited, startendpos, rownumbers, colnumbers, speed) {\r\n    \r\n    // for Speed of animation\r\n    var sleepms = 4; // 4 is minimum\r\n    if(speed == \"Instant\"){sleepms = 0;}\r\n    if(speed == \"Speed\"){sleepms = 4;}\r\n    if(speed == \"Fast\"){sleepms = 4;}\r\n    if(speed == \"Medium\"){sleepms = 200;}\r\n    if(speed == \"Slow\"){sleepms = 1000;}\r\n      \r\n\r\n    const startRow = startendpos[0]; // row number of start\r\n    const startCol = startendpos[1]; // col number of start\r\n    const endRow = startendpos[2];\r\n    const endCol = startendpos[3];\r\n\r\n    var newArray = [...maingrid]; //clone maingrid \r\n    \r\n    // Getting starting positions \r\n    var currentPosX = startRow;\r\n    var currentPosY = startCol;\r\n    \r\n    // Gathers all visited Nodes so that we wont visit again\r\n    var visitedNodes = [];\r\n    // add start node as visited\r\n    visitedNodes.push(startRow + \":\" + startCol) // add startNode cuz no need to visit again\r\n\r\n    var distance = []; // Distance of each nodes to start\r\n    var previousNode = []; // Previous Nodes\r\n\r\n    // Important\r\n    // VertexSetQ contains distance of Node f/ start , Row number, Column number\r\n    var vertexSetQ = []; \r\n\r\n    var targetreached = false; // check if target is reacher\r\n\r\n    // calculating h (heuristics) from start\r\n    var h = getHeuristic(startRow, startCol, endRow, endCol);\r\n\r\n    for (var row = 0; row < rownumbers; row++) {\r\n      distance[row] = [];\r\n      previousNode[row] = [];\r\n      //vertexSetQ[row] = [];\r\n      for (var col = 0; col < colnumbers; col++) {\r\n        distance[row][col] = Infinity; // first is Type, second: X of previous node; third : Y of previous node\r\n        previousNode[row][col] = [-1,-1]; // first is Type, second: X of previous node; third : Y of previous node\r\n        if(row == startRow && col == startCol){distance[row][col] = 0 + h;}\r\n      }\r\n    }\r\n    vertexSetQ.push([0, startRow, startCol]);\r\n\r\n    var numberofVisitedNodes = 0;\r\n\r\n    while(targetreached == false){\r\n      \r\n      vertexSetQ = vertexSetQ.sort(function(a,b) {return a[0]-b[0]});\r\n      var u = vertexSetQ[0];\r\n      vertexSetQ.shift(); // remove the smallest node from stack\r\n      \r\n      var currentPosX = u[1];\r\n      var currentPosY = u[2];\r\n      //alert(currentPosX);\r\n      var weight = 1; // Change weight if necessary\r\n\r\n      // if target is reached, stop everything\r\n      if(currentPosX === endRow && currentPosY === endCol){\r\n        targetreached = true;\r\n        break;\r\n      }\r\n      \r\n      var f = 0;\r\n\r\n      // add this current node to visited\r\n      visitedNodes.push(currentPosX + \":\" + currentPosY)\r\n      \r\n      if(visitedNodes.includes((currentPosX-1) + \":\" + currentPosY)  === false && currentPosX-1 >= 0 && isWall(currentPosX-1, currentPosY) == false ){\r\n        var alt = distance[currentPosX][currentPosY] + weight;\r\n        if(alt < distance[currentPosX-1][currentPosY]){\r\n          distance[currentPosX-1][currentPosY] = alt;\r\n          previousNode[currentPosX-1][currentPosY] = [currentPosX, currentPosY];\r\n          \r\n          f = distance[currentPosX-1][currentPosY] + getHeuristic(currentPosX-1, currentPosY, endRow, endCol)\r\n\r\n          vertexSetQ.unshift([f,currentPosX-1,currentPosY])\r\n          newArray[currentPosX-1][currentPosY][0] = 4;\r\n          numberofVisitedNodes++;\r\n        }\r\n      }\r\n\r\n      if(visitedNodes.includes(currentPosX + \":\" + (currentPosY-1) ) === false && currentPosY-1 >= 0 && isWall(currentPosX, currentPosY-1) == false ){\r\n        var alt = distance[currentPosX][currentPosY] + weight;\r\n        if(alt < distance[currentPosX][currentPosY-1]){\r\n          distance[currentPosX][currentPosY-1] = alt;\r\n          previousNode[currentPosX][currentPosY-1] = [currentPosX, currentPosY];\r\n\r\n          f = distance[currentPosX][currentPosY-1] + getHeuristic(currentPosX, currentPosY-1, endRow, endCol)\r\n\r\n          vertexSetQ.unshift([f,currentPosX,currentPosY-1])\r\n          newArray[currentPosX][currentPosY-1][0] = 4;\r\n          numberofVisitedNodes++;\r\n        }\r\n      }\r\n      if(visitedNodes.includes((currentPosX+1) + \":\" + currentPosY)  === false && currentPosX+1 < rownumbers && isWall(currentPosX+1, currentPosY) == false ){\r\n        var alt = distance[currentPosX][currentPosY] + weight;\r\n        if(alt < distance[currentPosX+1][currentPosY]){\r\n          distance[currentPosX+1][currentPosY] = alt;\r\n          previousNode[currentPosX+1][currentPosY] = [currentPosX, currentPosY];\r\n\r\n          f = distance[currentPosX+1][currentPosY] + getHeuristic(currentPosX+1, currentPosY, endRow, endCol)\r\n          \r\n          vertexSetQ.unshift([f,currentPosX+1,currentPosY])\r\n          newArray[currentPosX+1][currentPosY][0] = 4;\r\n          numberofVisitedNodes++\r\n        }\r\n      }\r\n      if(visitedNodes.includes(currentPosX + \":\" + (currentPosY+1))  === false && currentPosY+1 < colnumbers && isWall(currentPosX, currentPosY+1) == false){\r\n        var alt = distance[currentPosX][currentPosY] + weight;\r\n        if(alt < distance[currentPosX][currentPosY+1]){\r\n          distance[currentPosX][currentPosY+1] = alt;\r\n          previousNode[currentPosX][currentPosY+1] = [currentPosX, currentPosY];\r\n\r\n          f = distance[currentPosX][currentPosY+1] + getHeuristic(currentPosX, currentPosY+1, endRow, endCol)\r\n\r\n          vertexSetQ.unshift([f,currentPosX,currentPosY+1])\r\n          newArray[currentPosX][currentPosY+1][0] = 4;\r\n          numberofVisitedNodes++;\r\n        }\r\n      }\r\n      \r\n      if(sleepms !== 0){\r\n        await sleep((sleepms));\r\n      }\r\n      updateGrid([...newArray]);\r\n    }\r\n    \r\n    updateNodesVisited(prev => prev + numberofVisitedNodes + 1);\r\n    \r\n    // Backtracking from End Node to Start Node\r\n    var shortestPath = [];\r\n    var btrow = endRow; // backtracking to start\r\n    var btcol = endCol;\r\n\r\n    if (typeof previousNode[endRow][endCol] !== 'undefined'){\r\n      while(true){\r\n        if(btrow == startRow && btcol == startCol){\r\n          break;\r\n        }\r\n        shortestPath.unshift([btrow,btcol]);\r\n        var temp = previousNode[btrow][btcol];\r\n        btrow = temp[0];\r\n        btcol = temp[1];\r\n      }\r\n    }\r\n    \r\n    var pathdistance = 0;\r\n    for(var i = 0; i< shortestPath.length; i++){\r\n      newArray[shortestPath[i][0]][shortestPath[i][1]][0] = 5;\r\n      \r\n      if(sleepms !== 0){\r\n        await sleep((sleepms));\r\n      }\r\n      pathdistance++;\r\n      updateFinalDistance(pathdistance)\r\n      updateGrid([...newArray]);\r\n    }\r\n  }\r\n\r\n  function getHeuristic(currentX,currentY,targetX,targetY){\r\n    //calculating heuristic value from one current node to target node\r\n    // pythagorus BUT no need square root since we'll get same results at the end\r\n    var heuristic =  Math.pow((targetX-currentX), 2) + Math.pow((targetY-currentY), 2)\r\n    return heuristic;\r\n  }\r\n\r\n\r\n  function sleep(time) {\r\n    return new Promise(resolve => setTimeout(()=>resolve(), time));\r\n  }","\r\n// Some explanations of this Maze Generation algorithm\r\n//http://weblog.jamisbuck.org/2011/1/12/maze-generation-recursive-division-algorithm\r\n// https://stackoverflow.com/questions/23530756/maze-recursive-division-algorithm-design\r\n\r\nvar outborder = false;\r\n\r\nexport async function recursivedivision(updateGrid, maingrid, width, height) {\r\n    var newArray = [...maingrid]; //clone maingrid \r\n    if(outborder == false){ // create out border only when not exist\r\n        CreateExtBorder(newArray,width,height);\r\n        outborder = true;\r\n        updateGrid([...newArray]);\r\n    }\r\n    updateGrid([...newArray]);\r\n\r\n    addInnerWalls(false, updateGrid, newArray, 1, width - 2, 1, height - 2);\r\n}\r\n\r\nfunction addInnerWalls(horizontal, updateGrid, newArray, minX, maxX, minY, maxY){\r\n    setTimeout( function () { if(horizontal){\r\n        if (maxX - minX < 2) {\r\n            return;\r\n        }\r\n\r\n        var y = Math.floor(randomNumber(minY, maxY)/2)*2;\r\n        addHWall(updateGrid, newArray, minX, maxX, y);\r\n\r\n        addInnerWalls(!horizontal, updateGrid, newArray, minX, maxX, minY, y-1);\r\n        addInnerWalls(!horizontal, updateGrid, newArray, minX, maxX, y + 1, maxY);\r\n    }\r\n    else{\r\n        if (maxY - minY < 2) {\r\n            return;\r\n        }\r\n        \r\n        var x = Math.floor(randomNumber(minX, maxX)/2)*2;\r\n        addVWall(updateGrid, newArray, minY, maxY, x);\r\n\r\n        addInnerWalls(!horizontal, updateGrid, newArray, minX, x-1, minY, maxY);\r\n        addInnerWalls(!horizontal, updateGrid, newArray, x + 1, maxX, minY, maxY);\r\n    }\r\n    }, 5);\r\n}\r\n\r\nfunction addHWall(updateGrid, newArray, minX, maxX, y) {\r\n    var hole = Math.floor(randomNumber(minX, maxX)/2)*2+1;\r\n\r\n    for (var i = minX; i <= maxX; i++) {\r\n        if (i == hole) newArray[y][i][0] = 0;\r\n        else newArray[y][i][0] = 1;\r\n    }\r\n    \r\n    updateGrid([...newArray]);\r\n}\r\n\r\nfunction addVWall(updateGrid, newArray, minY, maxY, x) {\r\n    var hole = Math.floor(randomNumber(minY, maxY)/2)*2+1;\r\n\r\n    for (var i = minY; i <= maxY; i++) {\r\n        if (i == hole) newArray[i][x][0] = 0;\r\n        else newArray[i][x][0] = 1;\r\n    }\r\n    \r\n    updateGrid([...newArray]);\r\n}\r\n\r\nfunction CreateExtBorder(grid, width, height){\r\n    for(var i = 0; i < width; i++){\r\n        grid[0][i][0] = 1;\r\n    }\r\n    for(var i = 0; i < height; i++){\r\n        grid[i][width-1][0] = 1;\r\n    }\r\n    for(var i = width-1; i > 0; i--){\r\n        grid[height-1][i][0] = 1;\r\n    }\r\n    for(var i = height-1; i > 0; i--){\r\n        grid[i][0][0] = 1;\r\n    }\r\n    return grid;\r\n}\r\n\r\n// Generate a random number between lowNum and highNum\r\nfunction randomNumber(lowNum, highNum) {\r\n    return Math.floor(Math.random() * (highNum - lowNum + 1)) + lowNum;\r\n}","\r\n// Some explanations of this Maze Generation algorithm\r\n//http://weblog.jamisbuck.org/2011/1/12/maze-generation-recursive-division-algorithm\r\n\r\nvar outborder = false;\r\n\r\nexport async function randomMaze(updateGrid, maingrid, row, col, width, height) {\r\n    var newArray = [...maingrid]; //clone maingrid \r\n    if(outborder == false){ // create out border only when not exist\r\n        CreateExtBorder(newArray,width,height);\r\n        outborder = true;\r\n        updateGrid([...newArray]);\r\n    }\r\n    updateGrid([...newArray]);\r\n\r\n    // CAN MODIFY THIS LATER FOR SETTINGS\r\n    var spacing = 5;  // opposite of densite : spacing \r\n\r\n    for (var row = 1; row < height-1; row++) {\r\n        for (var col = 1; col < width-1; col++) {\r\n            var rand = randomNumber(0,spacing);\r\n            if(rand == 0){\r\n                newArray[row][col][0] = 1; \r\n            }\r\n            else{\r\n                newArray[row][col][0] = 0; \r\n            }\r\n        }\r\n    }\r\n\r\n    updateGrid([...newArray]);\r\n}\r\n\r\nfunction CreateExtBorder(grid, width, height){\r\n    for(var i = 0; i < width; i++){\r\n        grid[0][i][0] = 1;\r\n    }\r\n    for(var i = 0; i < height; i++){\r\n        grid[i][width-1][0] = 1;\r\n    }\r\n    for(var i = width-1; i > 0; i--){\r\n        grid[height-1][i][0] = 1;\r\n    }\r\n    for(var i = height-1; i > 0; i--){\r\n        grid[i][0][0] = 1;\r\n    }\r\n    return grid;\r\n}\r\n\r\n// Generate a random number between lowNum and highNum\r\nfunction randomNumber(lowNum, highNum) {\r\n    return Math.floor(Math.random() * (highNum - lowNum + 1)) + lowNum;\r\n}","import logo from './logo.svg';\nimport './App.css';\nimport GridSquare from './Components/GridSquare'\nimport Dashboard from './Components/Dashboard';\nimport { useState , useMemo} from 'react';\nimport { DragDropContext , Droppable } from 'react-beautiful-dnd';\nimport { VscRunAll } from 'react-icons/vsc';\n\nimport {Dijkstra} from './Algorithms/Dijkstra'\nimport {Astar} from './Algorithms/Astar'\n\nimport {recursivedivision} from './Maze Algorithms/RecursiveDivision'\nimport {randomMaze} from './Maze Algorithms/RandomMaze'\n\nfunction App() {\n\n  //Creating The Grid Matrix\n  const rownumbers = 20;\n  const colnumbers = 40;\n\n  // Grid Nodes has Two Values : [0] is Value, [1] is CurrentWeight\n  var startgrid = []; //Matrix to start\n  for (var row = 0; row < rownumbers; row++) {\n    startgrid[row] = [];\n    for (var col = 0; col < colnumbers; col++) {\n      startgrid[row][col] = [0,0,0]; // first is Type, second: X of previous node; third : Y of previous node\n    }\n  }\n\n  //The Grid State\n  const [maingrid, updateGrid] = useState(useMemo(() => startgrid));\n\n  // Default Start Position with State [startX, startY, endX, endY]\n  const [startendpos, updateStartEndPos] = useState(useMemo(() => [5,10,7,12]));\n\n  // Toggle Start/End/Bomb Buttons\n  const [StartBtnclicked, updateStartBtn] = useState(false);\n  const [EndBtnclicked, updateEndBtn] = useState(false);\n\n  // change algorithm (from Dashboard)\n  const [algorithm, updateAlgorithm] = useState(\"Dijkstra's Algorithm\");\n\n  // change speed (from Dashboard)\n  const [speed, updateSpeed] = useState(\"Speed\");\n\n\n  const [maze, updateMaze] = useState(\"Generate Maze\");\n\n  // for display after algo animation\n  const [finaldistance, updateFinalDistance] = useState(0);\n\n  // number of nodes visited\n  const [nodesVisited, updateNodesVisited] = useState(0);\n\n  // Function to update Grid (called from GridSquare click)\n  const updatethegrid = (row, col, value) =>  {\n    maingrid[row][col][0] = value;\n  }\n\n  //Function to CLEAR Grid : \n  const clearGrid = () => {\n    const newArr = [];\n    for (var row = 0; row < rownumbers; row++) {\n      newArr[row] = [];\n      for (var col = 0; col < colnumbers; col++) {\n        newArr[row][col] = [0,0,0];\n      }\n    }\n    updateGrid([...newArr])\n    updateFinalDistance(0);\n    updateNodesVisited(0);\n  }\n  \n\n  //Function to REFRESH GRID WITH NEW START/END Locations...\n  const updateStartEnd = (newrow, newcol, updatewhat) => {\n    var newArray = [...maingrid]; //clone maingrid \n\n    //According to updatewhat: 2 is Start and 3 is End\n    //\n    if(updatewhat === 2){\n      // Erase previous Start with 0\n      for (var row = 0; row < rownumbers; row++) {\n        for (var col = 0; col < colnumbers; col++) {\n          //newArr[row][col] = '0';\n          if(newArray[row][col][0] === updatewhat){ //if Start Node then empty it\n            newArray[row][col][0] = 0\n          }\n        }\n      }\n      var newStartEnd = [...startendpos];\n      newStartEnd[0] = newrow;\n      newStartEnd[1] = newcol;\n      updateStartEndPos([...newStartEnd])\n      updateStartBtn(false)\n    }\n    \n    if(updatewhat === 3){\n      // Erase previous Start with 0\n      for (var row = 0; row < rownumbers; row++) {\n        for (var col = 0; col < colnumbers; col++) {\n          //newArr[row][col] = '0';\n          if(newArray[row][col][0] === updatewhat){\n            newArray[row][col][0] = 0\n          }\n        }\n      }\n      var newStartEnd = [...startendpos];\n      newStartEnd[2] = newrow;\n      newStartEnd[3] = newcol;\n      updateStartEndPos([...newStartEnd])\n      updateEndBtn(false)\n    }\n\n    updateGrid([...newArray]);\n  }\n\n  function VisualizeAlgorithm(){\n    updateFinalDistance(0);\n    updateNodesVisited(0);\n    if(algorithm === \"Dijkstra's Algorithm\"){\n      Dijkstra(maingrid, updateGrid, isWall, updateFinalDistance, updateNodesVisited, startendpos, rownumbers, colnumbers, speed);\n    }\n    if(algorithm === \"A* Algorithm\"){\n      Astar(maingrid, updateGrid, isWall, updateFinalDistance, updateNodesVisited, startendpos, rownumbers, colnumbers, speed);\n    }\n  }\n\n  function isWall(row,col) {\n    if(maingrid[row][col][0] == 1){\n        return true;\n    }\n    else{\n      return false;\n    }\n  }\n\n  function GenerateMaze(){\n    if(maze == \"Recursive Division\"){\n      recursivedivision(updateGrid, maingrid, colnumbers, rownumbers);\n    }\n    else{\n      if(maze == \"Random Maze\"){\n        randomMaze(updateGrid, maingrid, 0, 0, colnumbers, rownumbers);\n      }\n      else{\n        //recursivedivision(updateGrid, maingrid, colnumbers, rownumbers);\n        //alert(maze)\n       }\n    }\n  }\n\n\n\n  // Create Grid Display with TABLE :\n  var grid = [<></>];\n  for (var row = 0; row < rownumbers; row++) {\n        //grid[row] = [];\n    grid.push(<tr></tr>)\n    for (var col = 0; col < colnumbers; col++) {\n          grid.push(<td>\n            <GridSquare \n              row={row} \n              col={col} \n              maingrid={maingrid}\n              updatethegrid={updatethegrid} \n              updateGrid={updateGrid}\n              StartBtnclicked={StartBtnclicked} \n              updateStartEnd={updateStartEnd} \n              startendpos={startendpos}\n              EndBtnclicked={EndBtnclicked}/>\n            </td>)\n      }\n    }\n\n \n  return (\n    <div className=\"row\" >\n      <Dashboard \n        Grid={maingrid} \n        algorithm={algorithm}\n        updateAlgorithm={updateAlgorithm}\n        speed={speed}\n        finaldistance={finaldistance}\n        nodesVisited={nodesVisited}\n        updateSpeed={updateSpeed}\n        clearGrid={clearGrid} \n        maze = {maze}\n        updateMaze = {updateMaze}\n        updateStartBtn={updateStartBtn} \n        updateEndBtn={updateEndBtn} \n        VisualizeAlgorithm={VisualizeAlgorithm} \n        GenerateMaze={GenerateMaze}\n        updatethegrid={updatethegrid}\n        />\n\n      <DragDropContext>\n        <table className='grid-board '>\n            {grid}\n        </table>\n      </DragDropContext>\n      \n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}